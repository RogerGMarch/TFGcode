// Routines for digital processing of 3He detector signals
// A. Tarifeno-Saldivia, R.March
//VERSION:  25Oct21 @ 15:19
/////////////////////////////



#include "TROOT.h"
#include "TFile.h"
#include "TTree.h"
#include "TH1.h"
#include "TCanvas.h"
#include <fstream>
#include <iostream>
#include <string>



#include <stdio.h>
#include <sys/time.h>


#include "TF1.h"
#include "TTreeReader.h"


#include <vector>


using namespace std;





//****************************************************************************
// Import movies from tree n_TOF raw2root
TH1D* GetMovieRaw2root(string FileName="", string treeName=""){
    Short_t y;
    Float_t b;
    
    TFile *f = new TFile(FileName.c_str());
    TTree *t1 = (TTree*)f->Get(treeName.c_str());
    t1->SetBranchAddress("signal_y",&y);
    t1->SetBranchAddress("baseline",&b);

 
    
       Long64_t nentries = t1->GetEntries();
    TH1D * h   = new TH1D((treeName + "_wfm").c_str(),(treeName + "_wfm").c_str(),nentries,0,(Double_t) nentries);
    for (Long64_t i=0;i<nentries;i++) {
        t1->GetEntry(i);
        Double_t Sy=(Double_t) y;
        Double_t B=(Double_t) b;

        //cout<<i<<"\t"<<Sy<<"\t"<<B<<endl;
        h->SetBinContent(i,B-Sy);
  }

    return h;
}

//****************************************************************************
// Import movies from tree n_TOF raw2root+ select index, string

// To plot imported movies from raw2root (nTOF)
void PlotMovieFromRaw2root(string FileName="", string treeName=""){
    TH1D * raw= GetMovieRaw2root(FileName,treeName);
    raw->Draw("HIST");   
}

//****************************************************************************
// Import movies from *.txt files generated by Tektronix DPO5034
TH1D* ImportMovieDPO5034(string FileName=""){
    
    ifstream in(FileName.c_str());
    Int_t nbins;
    string dummy,Name;
    size_t lastindex = FileName.find_last_of("."); 

    Name = FileName.substr(0, lastindex); 
    cout<<"Importing "<<Name<<" ...\n";
    
    // Reading file header
    /// First line: extract number of bins
    in>>dummy>>dummy;
    in>>nbins;
    for(int i=1; i<=6 ; i++){
    getline(in, dummy); //first line
    }
    //cout<<nbins<<"\n"<<dummy<<endl;
    // Reading data, time column is skipped
    TH1D * h   = new TH1D(("wfm"+Name).c_str(),("wfm"+Name).c_str(),nbins,0,(Double_t) nbins);

    
    Double_t t,V;
    Int_t bin=0;
    while(in>>t>>V){
        bin++;
        h->SetBinContent(bin,V);
        //cout<<t<<"\t"<<V<<endl;
    }
    
    
    in.close();
    
    //h->Draw();
    return h;
}

// To plot imported movies from raw2root (nTOF)
void PlotMovieFromRaw2root(string FileName=""){
    TH1D * raw= ImportMovieDPO5034(FileName);
    raw->Draw("HIST");   
}

// Create root file for wfm's from  DPO5034
void createRootFileDPO5034(string outfile="", string flist=""){
    
    TFile *outputFile=new TFile(outfile.c_str(),"RECREATE");
    
    ifstream in(flist.c_str());
    string FileName;
    while(in>>FileName){
        TH1D * h=ImportMovieDPO5034(FileName);
        h->Write();
    }
    
    outputFile->Close();
}


//****************************************************************************
// Import movies from GASIFIC ttree

TH1D* GetMovieGASIFIC(string file="", int entry=0){

	if((TFile *) (gROOT->FindObject(file.c_str()))) delete (TFile *) (gROOT->FindObject(file.c_str()));
	TFile *f = TFile::Open(file.c_str());
	TTreeReader  myReader("BRIKENTree", f);
	TTreeReaderValue< std::vector<unsigned short>> eventSize(myReader, "Neutrons.Samples");

	myReader.SetEntry(entry);

	int enty=myReader.GetEntries(true);

	//cout <<"Total Entries: "<< enty <<endl;

	std::vector<unsigned short>  v;
	v=*eventSize;
    
    const int vsize=v.size();
    
    TString name= file;
    name.ReplaceAll(".root","");
    TString Finalname = name +  Form("_entry%d_wfm",entry);
  
	TH1D* wfm = new TH1D(((string) Finalname).c_str(),((string) Finalname).c_str(),v.size(),0.0,v.size());
    
	for (int i=0; i< vsize; i++){wfm->SetBinContent(i,v.at(i));} 

  	return wfm;
  	f->Close();   
}


// Plot the movies from GASIFIC rootfile
void plotWFMGASIFIC(string file="", int entry=0){
  TH1D* h=GetMovieGASIFIC(file,entry);
  h->Draw();
}






//****************************************************************************
// Calculate the smoothing derivative according to Petar's Zugek algorithm 
TH1D* DerivativeWFM(TH1D* inputWFM, int StepSize=0, Double_t escala=1.0, Double_t diffOffset=0.0){
  int bins= (inputWFM-> GetNbinsX());
  TH1D *WFM_derivative_ = ((TH1D *)(gROOT->FindObject("wfm_derivative"))); 
  delete WFM_derivative_;
  
  string NAME=(string)  inputWFM->GetName()+"_derivative";
  
  TH1D *WFM_derivative  = new TH1D(NAME.c_str(),NAME.c_str(),bins,0,bins);
  
  for (int i=1+StepSize; i<= bins-StepSize ; i++){
    double Fup=0.0, Flow=0.0;
    for (int j=1; j<=StepSize ; j++){
      Fup+=inputWFM -> GetBinContent(i+j);
      Flow+=inputWFM -> GetBinContent(i-j);
    }
    WFM_derivative -> SetBinContent(i,escala*(Fup-Flow)+diffOffset);
  }
  return WFM_derivative;
}

//****************************************************************************
// Smoothing algorithm: moving average
TH1D* SmoothWFM(TH1D* inputWFM, int StepSize=0){
  int bins= (inputWFM-> GetNbinsX());
  TH1D *SmoothWFM_ = ((TH1D *)(gROOT->FindObject("wfm_smooth"))); 
  delete SmoothWFM_;
  
    string NAME=(string) inputWFM->GetName()+"_smooth";

  
  
  TH1D *SmoothWFM = new TH1D(NAME.c_str(),NAME.c_str(),bins,0,bins);
  for (int i=1+StepSize; i<= bins-StepSize ; i++){
    double Fup=0.0, Flow=0.0;
    for (int j=1; j<=StepSize ; j++){
      Fup+=inputWFM -> GetBinContent(i+j);
      Flow+=inputWFM -> GetBinContent(i-j);
    }
    SmoothWFM -> SetBinContent(i,(Fup+Flow)/(2*StepSize));
  }
  return SmoothWFM;
}


//****************************************************************************
// Estimate threshold from projection histogran for derivative. Outputs estimated std dev

double getProjectionThreshold(TH1D* inputWFM){
    double PyW=inputWFM->GetMaximum();
    TH1D *WFM_derivativePy = new TH1D("Py_wfm_derivative","Py_wfm_derivative",10000,-PyW,PyW);
	
	int bins= (inputWFM-> GetNbinsX())-2;
	
	for(int i=1; i<= bins; i++){
		WFM_derivativePy->Fill(inputWFM->GetBinContent(i));
	}



	WFM_derivativePy->Fit("gaus","Q0");

	return WFM_derivativePy->GetFunction("gaus")->GetParameter(2); 
}
//****************************************************************************
// Calculate the TimeStamps for a movie. Outputs a vector with the positions of the Timestamps

vector<double> TimeStamp(TH1D* inputWFM,double Threshold=1.0,int StepSize=250){


	std:: vector<double> EventTS;
	int bins = (inputWFM-> GetNbinsX());
	int LastTS=0, CurTS;
	double last = 0.0;
	
			
	for(int i=1; i<bins; i++){
        double current= inputWFM->GetBinContent(i);
	    double next= inputWFM->GetBinContent(i+1);
  	
	    if( current >Threshold && last < current && current >next){
		    CurTS=i;

		    if(CurTS-LastTS >= 2*StepSize){
			    EventTS.push_back(i);
                cout << i << endl;
			    last = -100.0;	
		    }	

            LastTS = CurTS;	

	    }

	    last = current;

	}

	return EventTS;
}

//****************************************************************************
// Obtain the amplitude values for a movie with in a range of choice.

TH1D* AmplitudeWFM(TH1D* inputWFM, int wfmTime=0, int PreSamples=10, int IntegrationLength=100){


		TH1D *EventWFM = ((TH1D *)(gROOT->FindObject("wfm_event")));
		delete EventWFM;

		EventWFM = new TH1D("wfm_event","wfm_event",PreSamples+IntegrationLength,0,PreSamples+IntegrationLength);

		for (int i=0; i<= PreSamples+IntegrationLength; i++){

		EventWFM->SetBinContent(i+1,inputWFM->GetBinContent(wfmTime-PreSamples+i));

		}

		return EventWFM;
	}


//****************************************************************************
// Unfolding filter: test1 impulse response 1 pole
// Requires cheking, initial test didn't work!

TH1D* UnfWFM1(TH1D* OutWFM, Double_t Sampling_rate_MHz =20.0, Double_t Decay_factor_us=50.0){
    int bins= (OutWFM-> GetNbinsX());
    TH1D *InWFM = ((TH1D *)(gROOT->FindObject("InWFM"))); 
    delete InWFM;
    InWFM = new TH1D("InWFM","INWFM",bins,0,bins);
    
    // Calculate weigths
    Double_t dt=(1.0/(Sampling_rate_MHz*1.0e6));
    Double_t x=dt/(Decay_factor_us*1.0e-6);
    Double_t w1=exp(x-1.0)/x;
    Double_t w2=-2.0*exp(-1.0)/x;
    Double_t w3 = exp(-x-1.0)/x;
    
    cout<<" dt: "<<dt<<endl;

    cout<<" x: "<<x<<endl;

    cout<<" w1: "<<w1<<endl;
    cout<<" w2: "<<w2<<endl;
    cout<<" w3: "<<w3<<endl;
    
    for (int i=3; i<=bins ; i++){
        Double_t Sn=w1*OutWFM->GetBinContent(i);
        Sn+=w2*OutWFM->GetBinContent(i-1);
        Sn+=w3*OutWFM->GetBinContent(i-2);
        InWFM->SetBinContent(i,Sn);
    }
    
    return InWFM;
}


//****************************************************************************
// Unfolding filter:  single exp, jordanov94

TH1D* UnfSingleExpJordanov94(TH1D* WFM, Double_t Sampling_rate_MHz =20.0, Double_t Decay_factor_us=50.0){
    int nbins= (WFM-> GetNbinsX());
    
    Double_t dt=(1.0/(Sampling_rate_MHz*1.0e6));
    Double_t x=dt/(Decay_factor_us*1.0e-6);
    Double_t a=exp(x);
    Double_t M=1.0/(a-1.0);
    
    string NAME = (string) WFM->GetName() + "_hunf";

    
    TH1D * hunf   = new TH1D(NAME.c_str(),NAME.c_str(),nbins,0,(Double_t) nbins);
    
    for(int i=3 ; i<= nbins ; i++){
        double vout=WFM->GetBinContent(i);
        vout+=M*(WFM->GetBinContent(i) - WFM->GetBinContent(i-1));
        hunf->SetBinContent(i,vout);
    }
    
    return hunf;
    
}



//****************************************************************************
// General digital filter up to order 3: Page 322 DSP guide

TH1D* Gen3Filter(TH1D* WFM,
                 Double_t a0=0.0,
                 Double_t b1=0.0,
                 Double_t a1=0.0,
                 Double_t b2=0.0,
                 Double_t a2=0.0){
    int bins= (WFM-> GetNbinsX());
    //TH1D *filterWFM = ((TH1D *)(gROOT->FindObject("filterWFM"))); 
    //delete filterWFM;
    
    string NAME=(string) WFM->GetName()+"_filter"; 
    
      TH1D * filterWFM = new TH1D(NAME.c_str(),NAME.c_str(),bins,0,bins);
    
        for (int i=3; i<=bins ; i++){
            Double_t yn=a0*WFM->GetBinContent(i);
            yn+=a1*WFM->GetBinContent(i-1);
            yn+=a2*WFM->GetBinContent(i-2);
            yn+=b1*filterWFM->GetBinContent(i-1);
            yn+=b2*filterWFM->GetBinContent(i-2);
            filterWFM->SetBinContent(i,yn);
        }
    return filterWFM;
}



//****************************************************************************
//  Moving Window Deconvolution
// Master thesis Forsberg
TH1D* SingleExpIntegrator(TH1D* WFM, 
                          Double_t Sampling_rate_MHz =20.0, 
                          Double_t Decay_factor_us=50.0){
    
    
        int nbins= (WFM-> GetNbinsX());
    
    
    Double_t dt=(1.0/(Sampling_rate_MHz*1.0e6));
    Double_t x=dt/(Decay_factor_us*1.0e-6);
    
    string NAME = (string) WFM->GetName() + "_SEint";

    
    TH1D * hint   = new TH1D(NAME.c_str(),NAME.c_str(),nbins,0,(Double_t) nbins);
    
        for(int i=3 ; i<= nbins ; i++){
        double vout=WFM->GetBinContent(i);
        vout+=-(1.0-x)*WFM->GetBinContent(i-1);
        vout+=hint->GetBinContent(i-1);
        hint->SetBinContent(i,vout);
    }
    
    return hint;
    
}




//****************************************************************************
// Spliting regions of a full movie
TH1D* SplitMovie(TH1D* inputWFM, Int_t startBin, Int_t finalBin){
    
    const Int_t bins=finalBin-startBin+1;
    TH1D* WFM = new TH1D("wfm","wfm",bins,0,finalBin-startBin);
    Int_t l=0;
    for(int i=startBin ; i<= finalBin ; i++){
        l++;
        WFM->SetBinContent(l,inputWFM->GetBinContent(i));
    }

    return WFM;
}








